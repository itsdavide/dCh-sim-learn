#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Graphs creation for the paper:

C. Marsala, D. Petturiti, and B. Vantaggi.
Adding Semantics to Fuzzy Similarity Measures Through the d-Choquet Integral.
In: Z. Bouraoui and S. Vesic (Eds.), Symbolic and Quantitative Approaches to 
Reasoning with Uncertainty. ECSQARU 2023, Volume 14294 of Lecture Notes 
in Computer Science, Springer, pp. 386â€“399, 2023.  
"""

import numpy as np
import matplotlib.pyplot as plt

ps = np.arange(0.5, 5, 0.5)
E_Iris = 0.9400782361308677 * 100
Cos_Iris = 0.7928520625889046 * 100

# p1 Iris S1 1-additive
A_p1_1_1 = np.array([[0.68421053, 0.67763158, 0.66216217, 0.61486486],
       [0.71710526, 0.66447369, 0.67567568, 0.70945946],
       [0.71710527, 0.69736842, 0.73648649, 0.73648649],
       [0.73026316, 0.68421053, 0.81081081, 0.71621622],
       [0.73684211, 0.69078948, 0.81756757, 0.75      ],
       [0.73684211, 0.71052632, 0.7972973 , 0.75675676],
       [0.72368422, 0.71052632, 0.83783784, 0.77027027],
       [0.73026316, 0.73026316, 0.83783784, 0.78378378],
       [0.73026316, 0.76315789, 0.83108108, 0.77027027]])

# p1 Iris S2 1-additive
A_p1_2_1 = np.array([[0.73684211, 0.75      , 0.86486486, 0.85135135],
       [0.73684211, 0.76973684, 0.86486486, 0.87162162],
       [0.73684211, 0.74342105, 0.86486486, 0.81756757],
       [0.73684211, 0.76973684, 0.86486486, 0.83108108],
       [0.74342105, 0.76973684, 0.86486486, 0.81081081],
       [0.73684211, 0.76973684, 0.86486486, 0.81756757],
       [0.73684211, 0.78947368, 0.86486486, 0.81756757],
       [0.73684211, 0.78289473, 0.86486486, 0.81756757],
       [0.73684211, 0.78947368, 0.86486486, 0.83108108]])

# p1 Iris S3 1-additive
A_p1_3_1 = np.array([[0.96052632, 0.8618421 , 0.92567568, 0.91216216],
       [0.96710526, 0.91447368, 0.93918919, 0.88513513],
       [0.95394737, 0.90789473, 0.91216216, 0.91891892],
       [0.95394737, 0.875     , 0.95945946, 0.95945946],
       [0.98684211, 0.875     , 0.94594595, 0.96621621],
       [1.        , 0.875     , 0.94594595, 0.97297297],
       [1.        , 0.88157895, 0.94594595, 0.95945946],
       [1.        , 0.875     , 0.9527027 , 0.94594595],
       [1.        , 0.88157895, 0.94594595, 0.94594595]])

# p1 Iris S1 2-additive
A_p1_1_2 = np.array([[0.68421053, 0.67763158, 0.65540541, 0.67567568],
       [0.68421053, 0.67105264, 0.68243243, 0.7027027 ],
       [0.69736842, 0.69736842, 0.69594595, 0.73648649],
       [0.69736842, 0.70394737, 0.75675676, 0.75675676],
       [0.70394737, 0.70394737, 0.76351351, 0.75      ],
       [0.71710527, 0.70394737, 0.77702703, 0.74324324],
       [0.71710527, 0.70394737, 0.78378379, 0.75675676],
       [0.71710527, 0.70394737, 0.83783784, 0.76351351],
       [0.71710527, 0.71710527, 0.80405405, 0.77702703]])

# p1 Iris S2 2-additive
A_p1_2_2 = np.array([[0.75      , 0.78289473, 0.83783783, 0.8445946 ],
       [0.74342105, 0.76315789, 0.86486486, 0.86486486],
       [0.75      , 0.76315789, 0.83783784, 0.88513513],
       [0.73684211, 0.76315789, 0.85135135, 0.85135135],
       [0.74342105, 0.76315789, 0.85135135, 0.85810811],
       [0.75      , 0.76315789, 0.8581081 , 0.81756757],
       [0.74342105, 0.76973684, 0.85135135, 0.81081081],
       [0.73684211, 0.76973684, 0.86486486, 0.81756757],
       [0.73684211, 0.78289473, 0.8581081 , 0.81081081]])

# p1 Iris S3 2-additive
A_p1_3_2 = np.array([[0.96710526, 0.88815789, 0.95945946, 0.89864865],
       [0.97368421, 0.89473684, 0.94594595, 0.93918919],
       [0.97368421, 0.90789473, 0.9527027 , 0.9527027 ],
       [0.96052632, 0.89473684, 0.93918919, 0.9527027 ],
       [0.97368421, 0.90789473, 0.94594595, 0.97972973],
       [0.98684211, 0.92105263, 0.94594595, 0.97297297],
       [1.        , 0.92763158, 0.9527027 , 0.97297297],
       [1.        , 0.93421053, 0.9527027 , 0.96621622],
       [1.        , 0.88815789, 0.95945946, 0.93918919]])

# Compute the mean accuracy
M_p1_1_1 = np.array([A_p1_1_1[i, :].mean() for i in range(len(ps))]) * 100
M_p1_2_1 = np.array([A_p1_2_1[i, :].mean() for i in range(len(ps))]) * 100
M_p1_3_1 = np.array([A_p1_3_1[i, :].mean() for i in range(len(ps))]) * 100
M_p1_1_2 = np.array([A_p1_1_2[i, :].mean() for i in range(len(ps))]) * 100
M_p1_2_2 = np.array([A_p1_2_2[i, :].mean() for i in range(len(ps))]) * 100
M_p1_3_2 = np.array([A_p1_3_2[i, :].mean() for i in range(len(ps))]) * 100

plt.figure(figsize=(6, 4))
plt.title(r'Iris dataset: PSO, $\delta_{p,1}$')
plt.plot(ps, M_p1_1_1, marker='o', color='green')
plt.plot(ps, M_p1_1_2, marker='o', color='green', linestyle='dashed')
plt.plot(ps, M_p1_2_1, marker='o', color='red')
plt.plot(ps, M_p1_2_2, marker='o', color='red', linestyle='dashed')
plt.plot(ps, M_p1_3_1, marker='o', color='blue')
plt.plot(ps, M_p1_3_2, marker='o', color='blue', linestyle='dashed')
plt.plot(ps, np.ones(len(ps)) * E_Iris, color='magenta', linestyle='dashed')
plt.plot(ps, np.ones(len(ps)) * Cos_Iris, color='darkorange', linestyle='dashed')
plt.xlabel('$p$')
plt.ylabel('Mean accuracy (%)')
plt.savefig('AVG-iris-p1-PSO.png', dpi=300)