#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Graphs creation for the paper:

C. Marsala, D. Petturiti, and B. Vantaggi.
Adding Semantics to Fuzzy Similarity Measures Through the d-Choquet Integral.
In: Z. Bouraoui and S. Vesic (Eds.), Symbolic and Quantitative Approaches to 
Reasoning with Uncertainty. ECSQARU 2023, Volume 14294 of Lecture Notes 
in Computer Science, Springer, pp. 386â€“399, 2023.  
"""

import numpy as np
import matplotlib.pyplot as plt

ps = np.arange(0.5, 5, 0.5)
E_Iris = 0.9400782361308677 * 100
Cos_Iris = 0.7928520625889046 * 100

# 1p Iris S1 1-additive
A_1p_1_1 = np.array([[0.68421053, 0.71052632, 0.72297297, 0.72972973],
       [0.69736842, 0.63157895, 0.68918919, 0.71621621],
       [0.45394737, 0.68421053, 0.68918919, 0.67567568],
       [0.6381579 , 0.68421053, 0.66216216, 0.69594595],
       [0.67763158, 0.68421053, 0.67567568, 0.7027027 ],
       [0.67763158, 0.67105264, 0.54054054, 0.74324324],
       [0.72368422, 0.625     , 0.50675676, 0.66216216],
       [0.69736842, 0.58552632, 0.56756757, 0.67567568],
       [0.73684211, 0.57894737, 0.56081081, 0.66891892]])

# 1p Iris S2 1-additive
A_1p_2_1 = np.array([[0.76315789, 0.78947368, 0.86486486, 0.8581081 ],
       [0.73684211, 0.76315789, 0.86486486, 0.8581081 ],
       [0.88157895, 0.8618421 , 0.92567568, 0.83783784],
       [0.83552632, 0.82894736, 0.9054054 , 0.81081081],
       [0.83552631, 0.82236842, 0.9054054 , 0.78378378],
       [0.79605263, 0.80921052, 0.9054054 , 0.70945946],
       [0.76315789, 0.83552631, 0.79054054, 0.70945946],
       [0.77631579, 0.82894736, 0.78378378, 0.66216216],
       [0.76973684, 0.81578947, 0.78378378, 0.62162162]])

# 1p Iris S3 1-additive
A_1p_3_1 = np.array([[0.93421053, 0.77631578, 0.8581081 , 0.85135135],
       [0.96710526, 0.90131579, 0.91891892, 0.9054054 ],
       [0.98684211, 0.8618421 , 0.99324324, 0.94594595],
       [0.97368421, 0.84210526, 0.95945946, 0.89864865],
       [0.96052632, 0.85526316, 0.9527027 , 0.9054054 ],
       [0.93421053, 0.86842105, 0.9527027 , 0.91891892],
       [0.93421053, 0.8618421 , 0.96621621, 0.91891892],
       [0.93421053, 0.89473684, 0.95945946, 0.87162162],
       [0.94078947, 0.89473684, 0.91891892, 0.79054054]])

# 1p Iris S1 2-additive
A_1p_1_2 = np.array([[0.70394737, 0.71052632, 0.71621621, 0.72972973],
       [0.68421053, 0.68421053, 0.67567568, 0.7027027 ],
       [0.68421053, 0.70394737, 0.66216217, 0.69594594],
       [0.64473684, 0.68421053, 0.65540541, 0.65540541],
       [0.68421053, 0.68421053, 0.64864865, 0.53378379],
       [0.68421053, 0.68421053, 0.64864865, 0.63513514],
       [0.68421053, 0.65789474, 0.66891892, 0.60135135],
       [0.68421053, 0.59868421, 0.69594595, 0.62162162],
       [0.68421053, 0.61184211, 0.67567568, 0.57432433]])

# 1p Iris S2 2-additive
A_1p_2_2 = np.array([[0.76315789, 0.77631578, 0.8581081 , 0.86486486],
       [0.75      , 0.76315789, 0.82432432, 0.86486486],
       [0.81578947, 0.82894736, 0.87162162, 0.84459459],
       [0.84868421, 0.82236842, 0.89864865, 0.77702703],
       [0.81578947, 0.80263157, 0.89864865, 0.83783784],
       [0.76973684, 0.80921052, 0.88513513, 0.77027027],
       [0.76315789, 0.80921052, 0.84459459, 0.7027027 ],
       [0.78947368, 0.80263158, 0.83108108, 0.75675676],
       [0.79605263, 0.78289473, 0.83783783, 0.69594595]])

# 1p Iris S3 2-additive
A_1p_3_2 = np.array([[0.875     , 0.73684211, 0.89189189, 0.82432432],
       [0.96710526, 0.88815789, 0.91216216, 0.91216216],
       [0.97368421, 0.84210526, 0.94594595, 0.93243243],
       [0.96710526, 0.86842105, 0.94594595, 0.92567568],
       [0.95394737, 0.85526316, 0.93243243, 0.91891892],
       [0.96052632, 0.84210526, 0.95270271, 0.91216216],
       [0.95394737, 0.82894737, 0.94594595, 0.89864865],
       [0.93421053, 0.80263158, 0.91216216, 0.91216216],
       [0.92105263, 0.82236842, 0.92567568, 0.8445946 ]])

# Compute the mean accuracy
M_1p_1_1 = np.array([A_1p_1_1[i, :].mean() for i in range(len(ps))]) * 100
M_1p_2_1 = np.array([A_1p_2_1[i, :].mean() for i in range(len(ps))]) * 100
M_1p_3_1 = np.array([A_1p_3_1[i, :].mean() for i in range(len(ps))]) * 100
M_1p_1_2 = np.array([A_1p_1_2[i, :].mean() for i in range(len(ps))]) * 100
M_1p_2_2 = np.array([A_1p_2_2[i, :].mean() for i in range(len(ps))]) * 100
M_1p_3_2 = np.array([A_1p_3_2[i, :].mean() for i in range(len(ps))]) * 100

plt.figure(figsize=(6, 4))
plt.title(r'Iris dataset: PSO, $\delta_{1,p}$')
plt.plot(ps, M_1p_1_1, marker='o', color='green')
plt.plot(ps, M_1p_1_2, marker='o', color='green', linestyle='dashed')
plt.plot(ps, M_1p_2_1, marker='o', color='red')
plt.plot(ps, M_1p_2_2, marker='o', color='red', linestyle='dashed')
plt.plot(ps, M_1p_3_1, marker='o', color='blue')
plt.plot(ps, M_1p_3_2, marker='o', color='blue', linestyle='dashed')
plt.plot(ps, np.ones(len(ps)) * E_Iris, color='magenta', linestyle='dashed')
plt.plot(ps, np.ones(len(ps)) * Cos_Iris, color='darkorange', linestyle='dashed')
plt.xlabel('$p$')
plt.ylabel('Mean accuracy (%)')
plt.savefig('AVG-iris-1p-PSO.png', dpi=300)